<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="addCommandButton.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAA7dJREFUaEPt
        mMmKFEEURdsZh40oiuMfiCIo+iGCLtyI4g8oDh/gtFVEULeKCm5E8C9EceWIohtHUHHalPc0WU3Eyxs5
        VFUvCvrCgcpXN6syMiPjvRczC1rQgsbXYDBYLPaLs+K+eCa+iH8VfCbGd2fEPsE5nDsWNtiD7eKS+CD6
        6r24ILYJ99udsMEObBDXBXd3XP0V18R64f6rERts4bD4KiYtptkh4f6ziA0WWCZuipK+i1viqNgj1onl
        FdxdYsfEbfFDlMTTWCrcNdSwQcMq8Ug4PRdHxErhznXwewz0hXB6KPC4czNsMMCddxf/S5wQne+Wgd8+
        JX6LKAbR+ts2GLghorhzO4Tzj8JO8UpEMZ2cfw4bTOCFjXosWIWcfxw2iici6qBw/llssIKL/CZScefn
        4+KHMIj4JD4LFgTnbxwA63wq5nyfaRPlPI5d4o9IdVU4b3EAZNiYpE4K5y0R5TwlTotUJLstouatBSoo
        D1KxVPZdbaKcpwSr00uR6ryoeWsBQZEVaxvWeedtIsp5miDppXonFonMlx1UUFWmIsP2SVJDopynidXi
        p0i1V2S+7KCCkjgV5YHztRHlPG3cEal4NzJPdlBBzZ6KlO98bUQ5TxvHRap7IvNkBxU0HqkowpyvjSjn
        aYPGJ9VTkXmygwrK2lSlJDJpuf8gaab6JDJPdlAR13/KYeebtNx/rBCpyAeZJzuomPoBxClUavUmLfcf
        I02hqX+J4zJKRnS+NqKcp42RllH2bVLRwzpfG1HO08ZdkYruLfNkBxXxsdGAd+pPA1HO08QaEUuJ2nTO
        Dioo5th0SjVKNo5ynibi9HkrOhVzcFGkohOjxHXeElHOU4Kl+7VIdU7UvLVABdt9MR/U5l8LUc5TIhaU
        dGibRc1bCySwI5CKrQ92D5zXEeU8jt0itpSXhfM2DoAEFpMaDTeNt/NPgk3ijUj1UawVzt84AGCvMoqt
        j/kYBBdPooo6IJx/FhsMxKmEeBLsHjj/KDBt4p1HV4Tzz2GDAZp5tvmieCfokPquTimsNrywcc6jB2KJ
        cOfNYYMGEpkbBGL3gHKDHtad6yBJsc7HpXIoLr5TH26DBXgSbjoNRcamh+XCyOZUkpTDwGdifEc9EzNs
        KqZN650fYoMt8GKz3Tdpsdo0vrAOG+wAbSbbfTQY44r5zzpfXCqbsMEebBXsmLHp1FfUNpQHNsN2xQZH
        gAKQTSdWJeY46zndE08I+EyM7yhJqCprhdko2OA0YYPThA1OEzY4PQxm/gOUO8f1FCkESwAAAABJRU5E
        rkJggg==
</value>
  </data>
  <metadata name="toolTipDisplay.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>58, 21</value>
  </metadata>
  <data name="commandArgumentsAllowsSpacesCheckBox.ToolTip" xml:space="preserve">
    <value>If checked, the last argument will be able to contain spaces:

Example with 2 arguments:
!player (1)[add] (2)[never gonna give you up]

If this property wasn't checked then the command would have been interpreted as follows:
! player (1)[add] (2)[never] (discarded arguments)[gonna give you up]</value>
  </data>
  <data name="commandTitlePrefixCheckbox.ToolTip" xml:space="preserve">
    <value>If unchecked, this command won't require to have the global prefix to be recognized.
Usefull to make the bot react to sentences.

Example with "Baybe don't hurt me" as the label and "Uses prefix" unchecked:
User: Baybe don't hurt me
Bot: No more!</value>
  </data>
  <data name="commandTitleIcon.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABGdBTUEAALGPC/xhBQAAARhJREFUaEPt
        1WFqwkAUBOD0RrZFrNRb+aMglCrtL+lVW209gM5DB0LYQDbZ9xZhPhgIgU1mULQRERERkdG2yNf1MtsD
        skPsGVXYi8+3fNuNDFb+E+H58BHt8sweGWqDdM+HjUiVPyErZKgZ8oN0n+M+okR5Ch9RsjyFjfAoT+4j
        PMuT24iI8lR8RGR5KjaiRnmaPKJmeZo0om/AKxLlESn+KfwjS8Tb5PKUGvGHvCBerPwv0n1vdnnqG7FA
        SitenlIjjsgcKeUJcSlPqREH5BmZyr08pUbYi63AWGHlqW+EfX9zhZen1Aj72bM/n6GqlafUiDUy1BvS
        PR9Wntoj3u1Gpvb58PJkL/64Xo5i56uVFxEREblvTXMBi0bubJ+bJwQAAAAASUVORK5CYII=
</value>
  </data>
  <data name="commandTitleIcon.ToolTip" xml:space="preserve">
    <value>Command labels follows this pattern:
[command prefix]&lt;command label&gt; [args]

Example:
!song add never gonna give you up

Command arguments define everything after the command label and are separated by spaces:

Example with 2 arguments:
!song (1)[add] (2)[never gonna give you up]</value>
  </data>
</root>